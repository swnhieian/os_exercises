# lab1 SPOC思考题

## 个人思考题

NOTICE
- 有"w2l2"标记的题是助教要提交到学堂在线上的。
- 有"w2l2"和"spoc"标记的题是要求拿清华学分的同学要在实体课上完成，并按时提交到学生对应的git repo上。
- 有"hard"标记的题有一定难度，鼓励实现。
- 有"easy"标记的题很容易实现，鼓励实现。
- 有"midd"标记的题是一般水平，鼓励实现。  

---

请描述ucore OS配置和驱动外设时钟的准备工作包括哪些步骤？ (w2l2)
```
  + 采分点：说明了ucore OS在让外设时钟正常工作的主要准备工作
  - 答案没有涉及如下3点；（0分）
  - 描述了对IDT的初始化，包了针时钟中断的中断描述符的设置（1分）
  - 除第二点外，进一步描述了对8259中断控制器的初始过程（2分）
  - 除上述两点外，进一步描述了对8253时钟外设的初始化，或描述了对EFLAG操作使能中断（3分）
 ```
- [x]  

> 初始化信息在kern_init()函数中  
1. 对IDT进行初始化：通过idt_init()函数中使用的SETGATE宏初始化中断向量表，初始化后通过`lidt`的汇编命令加载idt  
2. 对中断控制器进行初始化：通过pic_init()函数完成 ，通过汇编的out指令进行  
3. 对时钟进行初始化：通过clock_init()函数完成，主要通过汇编的out指令进行  

lab1中完成了对哪些外设的访问？ (w2l2)

 ```
  + 采分点：说明了ucore OS访问的外设
  - 答案没有涉及如下3点；（0分）
  - 说明了时钟（1分）
  - 除第二点外，进一步说明了串口（2分）
  - 除上述两点外，进一步说明了并口，或说明了CGA，或说明了键盘（3分）
 ```
- [x]  

>  有时钟（上一题clock.c文件）;在driver/console.c中发现了对串口、CGA、键盘等外设的相关描述和说明;在同一文件中有lpt_putc(c)可以看出这是对并口的访问。

lab1中的cprintf函数最终通过哪些外设完成了对字符串的输出？ (w2l2)
 ```
  + 采分点：说明了cprintf函数用到的3个外设
  - 答案没有涉及如下3点；（0分）
  - 说明了串口（1分）
  - 除第二点外，进一步说明了并口（2分）
  - 除上述两点外，进一步说明了CGA（3分）
 ```
- [x]  

>  分析cprintf()函数的执行过程，发现它调用vcprintf()；vcprintf()中调用vprintfmt()并把cputch()作为参数传入，在vprintfmt()中使用cputch()输出，而cputch()又调用了cons_putc()函数，它的实现如下：
```
void
cons_putc(int c) {
    lpt_putc(c);
    cga_putc(c);
    serial_putc(c);
}
```
由lpt、cga、serial前缀并简单查看实现可知分别是通过并口、cga和串口的输出。

---

## 小组思考题

---

lab1中printfmt函数用到了可变参，请参考写一个小的linux应用程序，完成实现定义和调用一个可变参数的函数。(spoc)
- [x]  

> 程序如下：
```
#include <stdarg.h>
#include <stdio.h>
void sum(int n, ...) {
  va_list arg_ptr;
  int sum = 0;
  va_start(arg_ptr, n);
  for (int i = 0; i < n; i++) 
    sum += va_arg(arg_ptr, int);
  va_end(arg_ptr);
  printf("sum : %d\n", sum);
  return ;
}
int main() {
  sum(2, 1, 2);
  sum(3, 1, 2, 3);
  sum(4, 1, 2, 3, 4);
  return 0;
}
```



如果让你来一个阶段一个阶段地从零开始完整实现lab1（不是现在的填空考方式），你的实现步骤是什么？（比如先实现一个可显示字符串的bootloader（描述一下要实现的关键步骤和需要注意的事项），再实现一个可加载ELF格式文件的bootloader（再描述一下进一步要实现的关键步骤和需要注意的事项）...） (spoc)
- [x]  

> 
+ 首先完成bootloader需要完成的对各种寄存器的初始化的过程  
主要对一些段寄存器赋初值
能够切换到x86保护模式
+ 写一个能显示字符串的bootloader  
主要完成对CGA、串口、并口的访问和设置
注意：  
注意CGA、串口的初始化，并口无需初始化
不同外设的访问方式不同
注意不同类型字符（数字、字母、其他字符等）的显示方式及控制格式的方法
+ 写一个可以加载ELF格式文件的bootloader  
主要根据ELF文件的格式来读取
读取完毕后跳转到ucore的第一条指令上执行  
注意：  
加载ELF文件的时候注意对其格式是否合法的检测及错误处理  
bootloader的总大小不能超地512字节否则无法放入一个扇区中  


如何能获取一个系统调用的调用次数信息？如何可以获取所有系统调用的调用次数信息？请简要说明可能的思路。(spoc)
- [x]  

> 　　在每次触发系统调用的时候进行统计，比如在每个系统调用开始执行的时候就把其计数信息加一，这样需要统计所有系统调用次数的时候只要在系统调用表中遍历所有的系统调用然后获取其调用次数即可。  
　　也可以在所有的系统调用之前设立一个统一的系统调用入口，这一入口处负责对所有的系统调用的次数信息进行维护，这样在需要的时候直接调用此处维护的数据即可。  
　　需要注意的是次数信息的初始化。  
　　另外，通过搜索引擎搜索之后，在stackoverflow可以搜索到
http://stackoverflow.com/questions/8757318/how-to-monitor-number-of-syscalls-executed-by-kernel
> 在这个问答帖中提供了如下思路：　　
> 1. 使用SystemTap脚本语言，进行统计，在原帖下已经有示例代码。SystemTap是一个监控、调试、诊断linux系统的工具。
> 2. 使用ptrace的工具，包括strace/ltrace等相关工具。　　
> ptrace的形式是：
```
#include <sys/ptrace.h>
int ptrace(int request, int pid, int addr, int data);
```
>　　Ptrace 提供了一种父进程可以控制子进程运行，并可以检查和改变它的核心image。它主要用于实现断点调试。一个被跟踪的进程运行中，直到发生一个信号。则进程被中止，并且通知其父进程。在进程中止的状态下，进程的内存空间可以被读写。父进程还可以使子进程继续执行，并选择是否是否忽略引起中止的信号。  
>　　strace/ltrace均基于ptrace实现，以strace为例，只需要strace -c ./foo，即可监控获得foo运行过程中的所有系统调用次数，自然也可以获取某一个特定系统调用的次数信息。  

如何裁减lab1, 实现一个可显示字符串"THU LAB1"且依然能够正确加载ucore OS的bootloader？如果不能完成实现，请说明理由。
- [x]  

> 

对于ucore_lab中的labcodes/lab1，我们知道如果在qemu中执行，可能会出现各种稀奇古怪的问题，比如reboot，死机，黑屏等等。请通过qemu的分析功能来动态分析并回答lab1是如何执行并最终为什么会出现这种情况？
- [x]  

> 

对于ucore_lab中的labcodes/lab1,如果出现了reboot，死机，黑屏等现象，请思考设计有效的调试方法来分析常在现背后的原因。
- [x]  

> 

---

## 开放思考题

---

如何修改lab1, 实现在出现除零错误异常时显示一个字符串的异常服务例程的lab1？
- [x]  

> 


在lab1/bin目录下，通过`objcopy -O binary kernel kernel.bin`可以把elf格式的ucore kernel转变成体积更小巧的binary格式的ucore kernel。为此，需要如何修改lab1的bootloader, 能够实现正确加载binary格式的ucore OS？ (hard)
- [x]  

>

GRUB是一个通用的bootloader，被用于加载多种操作系统。如果放弃lab1的bootloader，采用GRUB来加载ucore OS，请问需要如何修改lab1, 能够实现此需求？ (hard)
- [x]  

>


如果没有中断，操作系统设计会有哪些问题或困难？在这种情况下，能否完成对外设驱动和对进程的切换等操作系统核心功能？
- [x]  

>  

---

## 各知识点的小练习

### 4.1 启动顺序
---
读入ucore内核的代码？

- [x]  

> 

跳转到ucore内核的代码？

- [x]  

> 

全局描述符表的初始化代码？

- [x]  

> 

GDT内容的设置格式？初始映射的基址和长度？特权级的设置位置？

- [x]  

> 

可执行文件格式elf的各个段的数据结构？

- [x]  

> 

如果ucore内核的elf是否要求连续存放？为什么？

- [x]  

> 
---

### 4.2 C函数调用的实现
---

函数调用的stackframe结构？函数调用的参数传递方法有哪几种？
- [x]  

> 

系统调用的stackframe结构？系统调用的参数传递方法有哪几种？

- [x]  

> 
---

### 4.3 GCC内联汇编
---

使用内联汇编的原因？

- [x]  

> 特权指令、性能优化

对ucore中的一段内联汇编进行完整的解释？

- [x]  

> 
---

### 4.4 x86中断处理过程
---

4.4 x86中断处理过程

中断描述符表IDT的结构？

- [x]  

> 

中断描述表到中断服务例程的地址计算过程？

- [x]  

> 

中断处理中硬件压栈内容？用户态中断和内核态中断的硬件压栈有什么不同？

- [x]  

> 

中断处理中硬件保存了哪些寄存器？

- [x]  

> 
---

### 4.5 练习一 ucore编译过程
---

gcc编译、ld链接和dd生成两个映像对应的makefile脚本行？

- [x]  

> 
---

### 4.6 练习二 qemu和gdb的使用
---

qemu的命令行参数含义解释？

- [x]  

> 

gdb命令格式？反汇编、运行、断点设置

- [x]  

> 
---

### 练习三 加载程序
---

A20的使能代码分析？

- [x]  

> 

生成主引导扇区的过程分析？

- [x]  

> 

保护模式的切换代码？

- [x]  

> 

如何识别elf格式？对应代码分析？

- [x]  

> 

跳转到elf的代码？

- [x]  

> 
函数调用栈获取？

- [x]  

> 
---

### 4.8 练习四和五 ucore内核映像加载和函数调用栈分析
---

如何识别elf格式？对应代码分析？

- [x]  

> 

跳转到elf的代码？

- [x]  

> 

函数调用栈获取？
- [x]  

> 
---


### 4.9 练习六 完善中断初始化和处理
---

各种设备的中断初始化？
- [x]  

> 
中断描述符表IDT的排列顺序？
- [x]  

> 中断号
CPU加电初始化后中断是使能的吗？为什么？

- [x]  

> 
中断服务例程的入口地址在什么地方设置的？

- [x]  

> 
alltrap的中断号是在哪写入到trapframe结构中的？

- [x]  

> 
trapframe结构？
- [x]  

> 
---
